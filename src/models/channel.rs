/* 
 * Aeternity Epoch
 *
 * This is the [Aeternity](https://www.aeternity.com/) Epoch API.
 *
 * OpenAPI spec version: 0.25.0
 * Contact: apiteam@aeternity.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Channel {
  #[serde(rename = "id")]
  id: ::models::EncodedHash,
  #[serde(rename = "initiator_id")]
  initiator_id: ::models::EncodedHash,
  #[serde(rename = "responder_id")]
  responder_id: ::models::EncodedHash,
  #[serde(rename = "channel_amount")]
  channel_amount: i64,
  #[serde(rename = "initiator_amount")]
  initiator_amount: i64,
  #[serde(rename = "responder_amount")]
  responder_amount: i64,
  #[serde(rename = "channel_reserve")]
  channel_reserve: i64,
  #[serde(rename = "delegate_ids")]
  delegate_ids: Vec<::models::EncodedHash>,
  #[serde(rename = "state_hash")]
  state_hash: ::models::EncodedHash,
  #[serde(rename = "round")]
  round: i64,
  #[serde(rename = "solo_round")]
  solo_round: i64,
  #[serde(rename = "lock_period")]
  lock_period: i64,
  #[serde(rename = "locked_until")]
  locked_until: i64
}

impl Channel {
  pub fn new(id: ::models::EncodedHash, initiator_id: ::models::EncodedHash, responder_id: ::models::EncodedHash, channel_amount: i64, initiator_amount: i64, responder_amount: i64, channel_reserve: i64, delegate_ids: Vec<::models::EncodedHash>, state_hash: ::models::EncodedHash, round: i64, solo_round: i64, lock_period: i64, locked_until: i64) -> Channel {
    Channel {
      id: id,
      initiator_id: initiator_id,
      responder_id: responder_id,
      channel_amount: channel_amount,
      initiator_amount: initiator_amount,
      responder_amount: responder_amount,
      channel_reserve: channel_reserve,
      delegate_ids: delegate_ids,
      state_hash: state_hash,
      round: round,
      solo_round: solo_round,
      lock_period: lock_period,
      locked_until: locked_until
    }
  }

  pub fn set_id(&mut self, id: ::models::EncodedHash) {
    self.id = id;
  }

  pub fn with_id(mut self, id: ::models::EncodedHash) -> Channel {
    self.id = id;
    self
  }

  pub fn id(&self) -> &::models::EncodedHash {
    &self.id
  }


  pub fn set_initiator_id(&mut self, initiator_id: ::models::EncodedHash) {
    self.initiator_id = initiator_id;
  }

  pub fn with_initiator_id(mut self, initiator_id: ::models::EncodedHash) -> Channel {
    self.initiator_id = initiator_id;
    self
  }

  pub fn initiator_id(&self) -> &::models::EncodedHash {
    &self.initiator_id
  }


  pub fn set_responder_id(&mut self, responder_id: ::models::EncodedHash) {
    self.responder_id = responder_id;
  }

  pub fn with_responder_id(mut self, responder_id: ::models::EncodedHash) -> Channel {
    self.responder_id = responder_id;
    self
  }

  pub fn responder_id(&self) -> &::models::EncodedHash {
    &self.responder_id
  }


  pub fn set_channel_amount(&mut self, channel_amount: i64) {
    self.channel_amount = channel_amount;
  }

  pub fn with_channel_amount(mut self, channel_amount: i64) -> Channel {
    self.channel_amount = channel_amount;
    self
  }

  pub fn channel_amount(&self) -> &i64 {
    &self.channel_amount
  }


  pub fn set_initiator_amount(&mut self, initiator_amount: i64) {
    self.initiator_amount = initiator_amount;
  }

  pub fn with_initiator_amount(mut self, initiator_amount: i64) -> Channel {
    self.initiator_amount = initiator_amount;
    self
  }

  pub fn initiator_amount(&self) -> &i64 {
    &self.initiator_amount
  }


  pub fn set_responder_amount(&mut self, responder_amount: i64) {
    self.responder_amount = responder_amount;
  }

  pub fn with_responder_amount(mut self, responder_amount: i64) -> Channel {
    self.responder_amount = responder_amount;
    self
  }

  pub fn responder_amount(&self) -> &i64 {
    &self.responder_amount
  }


  pub fn set_channel_reserve(&mut self, channel_reserve: i64) {
    self.channel_reserve = channel_reserve;
  }

  pub fn with_channel_reserve(mut self, channel_reserve: i64) -> Channel {
    self.channel_reserve = channel_reserve;
    self
  }

  pub fn channel_reserve(&self) -> &i64 {
    &self.channel_reserve
  }


  pub fn set_delegate_ids(&mut self, delegate_ids: Vec<::models::EncodedHash>) {
    self.delegate_ids = delegate_ids;
  }

  pub fn with_delegate_ids(mut self, delegate_ids: Vec<::models::EncodedHash>) -> Channel {
    self.delegate_ids = delegate_ids;
    self
  }

  pub fn delegate_ids(&self) -> &Vec<::models::EncodedHash> {
    &self.delegate_ids
  }


  pub fn set_state_hash(&mut self, state_hash: ::models::EncodedHash) {
    self.state_hash = state_hash;
  }

  pub fn with_state_hash(mut self, state_hash: ::models::EncodedHash) -> Channel {
    self.state_hash = state_hash;
    self
  }

  pub fn state_hash(&self) -> &::models::EncodedHash {
    &self.state_hash
  }


  pub fn set_round(&mut self, round: i64) {
    self.round = round;
  }

  pub fn with_round(mut self, round: i64) -> Channel {
    self.round = round;
    self
  }

  pub fn round(&self) -> &i64 {
    &self.round
  }


  pub fn set_solo_round(&mut self, solo_round: i64) {
    self.solo_round = solo_round;
  }

  pub fn with_solo_round(mut self, solo_round: i64) -> Channel {
    self.solo_round = solo_round;
    self
  }

  pub fn solo_round(&self) -> &i64 {
    &self.solo_round
  }


  pub fn set_lock_period(&mut self, lock_period: i64) {
    self.lock_period = lock_period;
  }

  pub fn with_lock_period(mut self, lock_period: i64) -> Channel {
    self.lock_period = lock_period;
    self
  }

  pub fn lock_period(&self) -> &i64 {
    &self.lock_period
  }


  pub fn set_locked_until(&mut self, locked_until: i64) {
    self.locked_until = locked_until;
  }

  pub fn with_locked_until(mut self, locked_until: i64) -> Channel {
    self.locked_until = locked_until;
    self
  }

  pub fn locked_until(&self) -> &i64 {
    &self.locked_until
  }


}



