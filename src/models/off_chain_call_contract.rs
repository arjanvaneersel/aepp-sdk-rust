/* 
 * Aeternity Epoch
 *
 * This is the [Aeternity](https://www.aeternity.com/) Epoch API.
 *
 * OpenAPI spec version: 0.25.0
 * Contact: apiteam@aeternity.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct OffChainCallContract {
  #[serde(rename = "op")]
  op: String,
  /// Contract caller
  #[serde(rename = "caller")]
  caller: ::models::EncodedHash,
  /// Contract address
  #[serde(rename = "contract")]
  contract: ::models::EncodedHash,
  /// VM version of the contract
  #[serde(rename = "vm_version")]
  vm_version: i64,
  /// Amount of tokens to transfer to the contract
  #[serde(rename = "amount")]
  amount: i64,
  /// Gas limit for the contract call
  #[serde(rename = "gas")]
  gas: i64,
  /// Gas price for the contract call
  #[serde(rename = "gas_price")]
  gas_price: i64,
  /// Contract call data
  #[serde(rename = "call_data")]
  call_data: ::models::EncodedByteArray
}

impl OffChainCallContract {
  pub fn new(op: String, caller: ::models::EncodedHash, contract: ::models::EncodedHash, vm_version: i64, amount: i64, gas: i64, gas_price: i64, call_data: ::models::EncodedByteArray) -> OffChainCallContract {
    OffChainCallContract {
      op: op,
      caller: caller,
      contract: contract,
      vm_version: vm_version,
      amount: amount,
      gas: gas,
      gas_price: gas_price,
      call_data: call_data
    }
  }

  pub fn set_op(&mut self, op: String) {
    self.op = op;
  }

  pub fn with_op(mut self, op: String) -> OffChainCallContract {
    self.op = op;
    self
  }

  pub fn op(&self) -> &String {
    &self.op
  }


  pub fn set_caller(&mut self, caller: ::models::EncodedHash) {
    self.caller = caller;
  }

  pub fn with_caller(mut self, caller: ::models::EncodedHash) -> OffChainCallContract {
    self.caller = caller;
    self
  }

  pub fn caller(&self) -> &::models::EncodedHash {
    &self.caller
  }


  pub fn set_contract(&mut self, contract: ::models::EncodedHash) {
    self.contract = contract;
  }

  pub fn with_contract(mut self, contract: ::models::EncodedHash) -> OffChainCallContract {
    self.contract = contract;
    self
  }

  pub fn contract(&self) -> &::models::EncodedHash {
    &self.contract
  }


  pub fn set_vm_version(&mut self, vm_version: i64) {
    self.vm_version = vm_version;
  }

  pub fn with_vm_version(mut self, vm_version: i64) -> OffChainCallContract {
    self.vm_version = vm_version;
    self
  }

  pub fn vm_version(&self) -> &i64 {
    &self.vm_version
  }


  pub fn set_amount(&mut self, amount: i64) {
    self.amount = amount;
  }

  pub fn with_amount(mut self, amount: i64) -> OffChainCallContract {
    self.amount = amount;
    self
  }

  pub fn amount(&self) -> &i64 {
    &self.amount
  }


  pub fn set_gas(&mut self, gas: i64) {
    self.gas = gas;
  }

  pub fn with_gas(mut self, gas: i64) -> OffChainCallContract {
    self.gas = gas;
    self
  }

  pub fn gas(&self) -> &i64 {
    &self.gas
  }


  pub fn set_gas_price(&mut self, gas_price: i64) {
    self.gas_price = gas_price;
  }

  pub fn with_gas_price(mut self, gas_price: i64) -> OffChainCallContract {
    self.gas_price = gas_price;
    self
  }

  pub fn gas_price(&self) -> &i64 {
    &self.gas_price
  }


  pub fn set_call_data(&mut self, call_data: ::models::EncodedByteArray) {
    self.call_data = call_data;
  }

  pub fn with_call_data(mut self, call_data: ::models::EncodedByteArray) -> OffChainCallContract {
    self.call_data = call_data;
    self
  }

  pub fn call_data(&self) -> &::models::EncodedByteArray {
    &self.call_data
  }


}



